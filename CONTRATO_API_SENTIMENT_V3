### üìå Contrato T√©cnico ‚Äì Sentiment Analysis API (v3)

## 1. Objetivo

Definir el contrato t√©cnico para la integraci√≥n entre el servicio de an√°lisis de sentimiento
(Python / FastAPI) y el backend consumidor (Java / Spring Boot) en el contexto del hackathon.

---

## 2. Descripci√≥n del Servicio

La API recibe un texto en espa√±ol y devuelve la clasificaci√≥n de sentimiento junto con un nivel
de confianza asociado a la predicci√≥n.

---

## 3. Base URL

### Local / Docker

```
http://localhost:8000
```

### Docker (entre contenedores)

```
http://sentiment-api:8000
```

---

## 4. Endpoint Principal

### POST `/v3/analyze`

#### Request (JSON)

```json
{
  "text": "Excelente servicio y muy r√°pido"
}
```

---

#### Response Exitosa (200 OK)

```json
{
  "sentimiento": "positivo",
  "confianza": 0.87
}
```

---

## 5. Campos de Respuesta

| Campo       | Tipo   | Descripci√≥n                  |
| ----------- | ------ | ---------------------------- |
| sentimiento | string | positivo / negativo / neutro |
| confianza   | float  | Valor entre 0 y 1            |

---

## 6. Validaciones

* El campo `text` es obligatorio
* Longitud m√≠nima: 1 caracter
* Textos ambiguos pueden retornar `sentimiento = neutro` con menor confianza

---

## 7. Reglas de Integraci√≥n

* M√©todo HTTP: **POST**
* Content-Type: `application/json`
* Autenticaci√≥n: no requerida
* El backend Java **no debe usar GET**
* El contrato **no cambiar√° durante el hackathon**

---

## 8. Versionado

* `/v2` ‚Üí Contrato extendido (legacy / interno)
* `/v3` ‚Üí Contrato simplificado para integraci√≥n y demo

---

‚úîÔ∏è **Contrato cerrado y limpio**
‚úîÔ∏è No contradice tu trabajo previo
‚úîÔ∏è Alineado con lo que corre hoy

---

## 3Ô∏è‚É£ C√≥mo el equipo Java debe llamar la API

Ahora lo m√°s importante para ellos: **c√≥digo listo para copiar**.

---

## ‚òï Opci√≥n A ‚Äî RestTemplate (simple y suficiente)

### DTOs

```java
public class SentimentRequest {
    private String text;

    // getters y setters
}
```

```java
public class SentimentResponse {
    private String sentimiento;
    private Double confianza;

    // getters y setters
}
```

---

### Llamada con RestTemplate

```java
RestTemplate restTemplate = new RestTemplate();

String url = "http://sentiment-api:8000/v3/analyze";
// si es local fuera de Docker:
// String url = "http://localhost:8000/v3/analyze";

SentimentRequest request = new SentimentRequest();
request.setText("El servicio fue excelente y muy r√°pido");

HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);

HttpEntity<SentimentRequest> entity =
        new HttpEntity<>(request, headers);

ResponseEntity<SentimentResponse> response =
        restTemplate.postForEntity(
                url,
                entity,
                SentimentResponse.class
        );

SentimentResponse body = response.getBody();

System.out.println(body.getSentimiento());
System.out.println(body.getConfianza());
```

‚úîÔ∏è Simple
‚úîÔ∏è Claro
‚úîÔ∏è Ideal para hackathon

---

## ‚ö° Opci√≥n B ‚Äî WebClient (reactivo / moderno)

### Configuraci√≥n del cliente

```java
WebClient webClient = WebClient.builder()
        .baseUrl("http://sentiment-api:8000")
        .build();
```

---

### Llamada

```java
SentimentResponse response = webClient.post()
        .uri("/v3/analyze")
        .contentType(MediaType.APPLICATION_JSON)
        .bodyValue(new SentimentRequest("El servicio fue excelente y muy r√°pido"))
        .retrieve()
        .bodyToMono(SentimentResponse.class)
        .block();

System.out.println(response.getSentimiento());
System.out.println(response.getConfianza());
```

‚úîÔ∏è Ideal si ya usan WebFlux
‚úîÔ∏è No bloquea innecesariamente

---
